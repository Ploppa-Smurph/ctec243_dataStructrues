<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTEC 243 Data Structures wk01 - Lesson 01: Getting Organized</title>
</head>
<body>
<pre>
<h1>CTEC 243 Data Structures wk01 - Lesson 01: Getting Organized</h1>   
<h2>01.01: Classes, Objects, and Applications</h2>
    <b>Objects</b> - have information and behavior (they can perform actions); Simula67 was first object oriented programming language
        <b><i>Information</i></b> - attributes of the object
        <b><i>Behavior</i></b> - responsibilities of the object
    
    <b>Class</b> - define the structure of an object or set of objects. 
                   Class includes variables (data) and methods (actions)

    <i>static</i> - creates a 'class' variable - it will be the same for all objects in the class, it is a static variable and will not change.
    <i>final</i> - modifier states that the variable is in it's final form and cannot be modified, it creates a 'constant'
    <i>CONSTANTS</i> - naming convention, constants names are all UPPERCASE

    <b>constructors</b> - setter 
    <b>observers</b> - getter    
    <b>transformers</b> - allow object to be changed / modified

    <b>Access Control Modifiers</b>
        <b>public</b> - available everywhere
        <b>protected</b> - available within all subclasses
        <b>package</b> - available within the package
        <b>private</b> - only available within the class
    
    <b>Unified Method</b> - features 3 key elements: 
        <b><i>01) Use-case driven:</i></b>
        <b><i>02) Architecture-centric:</i></b> refers to structure of target system. 
        <b><i>03) Iterative and incremental:</i></b> involves development cycles that build on foundation of predecessors.

    <b>Unified Modeling Language (UML):</b> 
        ex: <i>Date myDate = new Date(6, 24, 1951);</i>
    
    <b>Java Virtual Machine</b>
    <b>Java Application</b> - the class that contains the 'main' method for the program

    <b>scanner class</b> - for input
    <b>Method Call</b>
<h2>01.02: Organizing Classes</h2>
    <h3>Inheritance</h3> - both an organizational and a reuse mechanism
        <i>subclass</i> - inherits features of it's superclass
        <i>superclass</i> - the class above a subclass, this is a class above a current class
        
        <b>immutable</b> - without change, protected from change
        <b>extends</b> - keyword indicating inheritance
        <b><i>super</i></b> - used to pass information to the superclass of the object

        <b>Inheritance Tree</b> - each class can extend only one additional class, inheritance relationship is therefore referred to as a tree. 
            - in Java the <b><i>Object class</i></b> is the root of the inheritance Tree
            - <i>@Override</i> - notation to override, used to redefine an inhereited method

        <b>Polymorphism</b> - greek for 'many forms'; a variable can reference objects of different classes at different times during the execution of a program. 
            - 2 major polmorphic references in Java: 
                =- Inheritance-based polymorphism (dealt with in this chapter)
                =- Interface-based polymorphism (we look at in chapter 2: Abstraction)

        <b>Run-time binding / dynamic binding</b> - 

    <h3>Packages</h3> - group together classes into packages as another form of organization
        - you can organize files into packages
        - compile a package separately and import it into a program.
        - make it easy for programs to use common class files.
        - help use avoid naming conflicts (2 classes CAN share the same name if they are in different packages)

        <b>Package Syntax</b> - ex: <i>package someName;</i> - most start with 'package' and end with the semi-colon
            - naming convention: packages start with lowercase letter to help distinguish from Class names. 

        <b>Compilation units</b> - can import packages that are created
            - packages can only have 1 public class per package, other classes in the packages are non-public
                ex: <i>package gamma;
                       public class One{...}
                       class Two{...} 
                </i>
            a programmer can then 'import' the public class 'One'. The file would need to be named 'One.java' to adhere to Java naming convention.
                - the file 'One.java' would be stored in the directory <b><i>gamma</i></b>

            * The 'import' statement:
                <i>import gamma.*;
                   import gamma.One; 
                </i>

<h2>01.03: Exceptional Situations</h2>
        <b>Handling Exceptional Situations</b> - typically referred to as 'Exceptions'
            - Define the exception: usually as a subclass of Java's <i>Exception</i> class
            - Generate (raising) the exception: recognize situation and use <i>throw</i> statement to 'announce' an exception has occured.
            - Handling the exception: use <i>try-catch</i> statement to discover that exception has been thrown and take appropriate action

        <b>Exceptions and Classes</b>
                
<h2>01.04: Data Structures</h2>
    <h3>Implementation-Dependent</h3>
        <b>Array</b> - used by accessing their position in the structure.
        <b>Linked List</b> - similar to a chain, each seperate element is linked to the element that follows in the list.
    <h3>Implementation-Independent</h3> - more abstractly stored structure than array or linked list
        <b>Stack</b> - LIFO
        <b>Queue</b> - FIFO, almost the opposite of stacks
        <b>Sorted List</b>
        <b>Map</b> - aka: dictionaries, tables, or 'associative array'; information is stored as a key:value pair 
            - the key must be unique, the value can be shared
        <b>Tree</b> - nonlinear; capable of having many successor / 'children' elements; beginning is the root, the root has no parent.
        <b>Graph</b> - made of elements called 'nodes' or 'vertices', also has 'edges'. Unlike trees there a no restrictions between elements - the edges describe relationships among vertices

    <b>What is a data structure?</b>
<h2>01.05: Basic Structuring Mechanisms</h2>
    <h3>Memory</h3>
    When doing Low-Level programming we deal with:
    <b>Direct vs Indirect addressing</b> 
        - Direct Addressing: corresponds to how 'primative variables' are used in Java
        - Indirect Addressing: for strings the 'str' denoting a string is stored a memory node, then each additional character is stored at another memory node block that is referenced at the initial stored 'str' node.

    <b>References</b>- aka links, addresses, or pointers
    <b>null</b> = absence of reference, this is a placeholder, letting the program know there could be a value in the future.

    <b>Primative types</b> - hold the value of a variable, 'by value'   
    <b>Reference types</b> - refer to a location where the value is stored, 'by reference'

    <b>Aliases</b> - refers to another previously assigned value, best to avoid aliases in programming where possible.
    <b>Garbage</b> - memory space allocated to a program that is no available to access by a program. garbage takes up memory
        * Java has a run-time garbage collection system that identifies and deallocates storage space; this returns the space to the free pool for the creation of new objects.               

    <b>Dynamic Memory Management</b> - process of allocating and deallocating memory into the free pool

    <b>Comparing Objects</b>- 'referenced' objects can only be identical using the '==' operator if one is an alias of the other. otherwise the program will see they contain to different reference pointers.
    <b>Parameters</b>

    <h3>Array</h3>
    The 2nd basic structuring construct is the Array. 

    programmers acces a sequence of locations using the array. 
        - Arrays are 'non-primative' and are handled by reference.
             - best not to use aliases on Arrays, since they are referenced, also effects 'comparison' and use of arguements. 

    <b>Arrays of Objects</b> - linear, has a sequence of elements

    <b>Two-Dimensional Arrays</b> - a table, has rows and columns
        ex: <i>
            double [][] alpha;
            alpha = new double[100][9]
        </i> 
    this code will create a new 'double' array with 100 rows and 9 columns.
        - 1st [] = row
        - 2nd [] = column   

    * in Java two-dimensional arrays = array of references to array objects
        ** three-dimensional arrays = a two-dimensional array whose elements are arrays.

<h2>01.06 Comparing Algorithms: Order of Growth Analysis</h2>
    <b>Algorithm</b> - 
        <b>Sequential search</b> - guess 1 number after the next until you find the answer, counting directly to the next sequential number.
        <b>Binary search</b> - eliminate half of the numbers each time by guessing the halfway mark and seeing if the value is higher or lower than the guessed amount. loop this process until you determine the number.

    <b>Measuring an Algorithm's Time Efficiency</b>
        <b>Best Case Complexity</b>
        <b>Average Case Complexity</b>
        <b>Worst Case Complexity</b>
    
    <b>Order of Growth</b>
    <b>Selection Sort</b>
    <b>Common Orders of Growth</b>

<h2>01.07: Summary</h2>
    This chapter is all about organization.
    <i>
             Object orientation allows developers to organize their solutions around models of re-
        ality, accruing benefits of understandability, reusability, and maintainability. The primary
        construct for creating systems using this approach is the class. Classes are used to create
        objects that work together to provide solutions to problems. Java’s inheritance mecha-
        nism and package construct help us organize our classes.
             Java’s exception handling mechanisms provide a powerful way to organize our sys-
        tem’s responses to special situations. We can choose to handle exceptional situations
        where they are first encountered or to throw the responsibility out to another level. A
        good understanding of this mechanism is a crucial ingredient for creating safe, reliable
        systems.
             Programs operate on data, so how the data are organized is of prime importance. Data
        structures deal with this organization. Several classic organizational structures have been
        identified through the years to help programmers create correct and efficient solutions
        to problems. The Java language provides basic structuring mechanisms for creating these
        structures—namely, the array and the reference mechanisms. Order of growth notation
        is an approach for classifying the efficiency of the algorithms that we will employ when
        implementing and using our data structures.
             Programmers are problem solvers. Object orientation allows seamless integration of
        problem analysis and design, resulting in problem solutions that are maintainable and
        reusable. Data structures provide ways of organizing the data of the problem domain so
        that solutions are correct and efficient. Staying organized is the key to solving difficult
        problems!
    </i>

<h2>01 - Project</h2>
- Create a program that simulates a small part of a Baseball game.  You should have a Pitcher who throws a Ball to a Batter, who will swing at the Ball either hitting it or striking out.

Your program should have a main class to test everything.  You should create a Pitcher and a Batter, then simulate three pitches and display whether they were hit or if they were missed.

Planning:
Ball
Create a Ball class that contains basic information on how fast it's travelling and where it currently is

Pitcher
Create a Pitcher class that can "throw" a Ball (meaning the pitcher should be able to add speed and direction to the ball).
It's okay if your Pitcher is able to conjure new Balls out of thin air at will
When your Pitcher throws a ball, they should throw it at a random speed within a specified range (the range can be whatever makes sense to you)

Batter
Create a Batter class who tries to "hit" the ball
The Batter needs a way to receive a ball from the Pitcher
To hit the ball, the batter should generate a random “speed check” number.  If the ball is going the speed check speed or slower, then the Batter successfully hits the ball.  If not, then the batter misses it.
Assume the Batter will hit the ball at the exact same speed as it is thrown.  This is a wacky game of baseball.

Main
In your base class in the main method, create a Pitcher and a Batter and simulate a number of tosses entered in by the user at run time, reporting the results to the console.

</pre>
</body>
</html>