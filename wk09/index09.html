<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTEC 243 Data Structures wk09: Binary Search Tree ADT</title>
</head>
<body>
<h1>CTEC 243 Data Structures wk09: Binary Search Tree ADT</h1>
<h2>07.01 - Trees</h2>
    <strong>Tree</strong> - structure with unique starting node (root). each node of a tree is capable of having multiple successors (children), but can only have a single predecessor (parent).
    <strong>Root</strong> - top node, no parent
    <strong>Parent Node</strong> - predecessor of a node
    <strong>Subtree</strong> - a node and all of it's decendants

    ** in a Tree - no child can have more than 1 parent... for each child there must be only 1 parent

    <strong>Ancestor</strong> - a parent of a node, or a parent of an ancestor  = predecessor nodes 
    <strong>Descendant</strong> - child of a node, or a child of a decendant    = successor nodes
    <strong>Leaf</strong> - a node with no children                             = endpoint of a branch
    <strong>Interior Node</strong> - Non-leaf nodes ??
    <strong>Siblings</strong> - nodes with the same parent  
    <strong>Level</strong> - distance from root (number of connections to root and self)
    <strong>Height</strong> - the max level of the tree

    <strong>Breadth-First Traversal</strong>
        aka "Level-Order Traversal" start at root, go down a level starting from left taking in all nodes before lowering to next level

        ** goes wider before going deeper

        <strong>** When programming Breadth-First Traversal we use a queue **</strong>
            you 1st: instantiate a queue of nodes
                2nd: if the root is != null
                    queue.enqueue(root)
                3rd: while !queue.isEmpty() 
                    dequeue an element from the node
                4th: enqueue children of node from left to right into new queue 

    <strong>Depth-First Traversal</strong>
        start at root and work your way down starting from the left to the bottom

        ** goes deep before going wide

        <strong>** When programming Depth-First Traversal we use a stack **</strong>
<h2>07.02 - Binary Tree</h2>
    each node is capable of having 2 child nodes, Left child node & Right child node

    <strong>Binary Search Tree</strong> = all values in Left Node <= than value of 'root'
                                        = all values in Right Node > than value of 'root'

    when maintaining an sorted list: 
        - Linked List requires O(N) find location (slow), O(1) to insert (quick)
        - Sorted Array requires O(logN) to find the location (relative fast), O(N) to insert (slow)
        - BST (Binary Search Tree) allows O(logN) to find (relative fast), O(1) to insert (quick)

    <strong>Preorder Traversal</strong> - root, left subtree (less than), then right subtree (greater than)
    <strong>Inorder Traversal</strong> - left, root, right
    <strong>Postorder Traversal</strong> - left, right, root

<h2>07.03 - Trees (HackerRank)</h2>
    <a href="https://youtu.be/oSWTXtMglKE">HackerRank Trees Video</a>

<h2>07.04 - BST (Binary Search Tree) Code Example</h2>
    see Projects/Java/243/BST

<h2>07 - Review</h2>
<strong>01) True or False? A depth-first traversal of a tree is also known as a level-order traversal.</strong>
    <em>False</em>
    
<strong>02) True or False? When a binary search tree is balanced, it provides O(log2N) search, addition, and removal.</strong>
    <em>True</em>

<strong>03) True or False? The number of nodes in a non-empty tree is equal to the number of nodes in its left subtree plus the number of nodes in its right subtree plus 1.</strong>
    <em>True</em>

<strong>04) True or False? When a binary search tree is balanced, it provides O(N2) search, addition, and removal</strong>
    <em>False</em>

<strong>05) Recall that within our BinarySearchTree class the root variable is of type BSTNode&lt;T&gt;. Which of
    the following code sequences could be used as the body of the isEmpty method?</strong>
    <em>return root == null</em>

<strong>06) For our binary search trees, the public method, size, calls the private recursive method, recSize,
    and passes it a reference to the root of the tree, returning to the caller whatever is returned to it by
    recSize. Critique the following implementation of recSize, assuming its parameter variable is node:</strong>
    <code>if (node == null)
        return 0;
    else
        return 1 + recSize(node.getLeft()) + recSize(node.getRight());</code>
    <em>the code works correctly</em>

<strong>07) Show the post-order traversal of the tree that results from starting with an empty tree and adding 10,
    20, 25, 5, 15, 17, 16, 14 and then removing 20.</strong>
    <em><strike>5, 14, 16, 17, 15, 25, 10</strike></em>

<strong>08) In the above tree, the descendants of node A are:</strong>
    <em>M, D, B, H, G, T</em>
    
<strong>09) Suppose xOrder is one of our binary search tree traversal methods that is passed a tree node node and a queue q. Which traversal order is provided by the following code?</strong>
<code>xOrder(node.getLeft(), q);
    xOrder(node.getRight(), q);
    q.enqueue(node.getInfo());</code>
    <em>post order</em>

<strong>10) Show the post-order traversal of the tree that results from starting with an empty tree and adding 10, 15, 18, 8, 9, 5 and then removing 9</strong>
    <em>5, 8, 18, 15, 10</em>

<strong>11) </strong>
    <em></em>

<strong>12) </strong>
    <em></em>

<strong>13) </strong>
    <em></em>

<strong>14) </strong>
    <em></em>

</body>
</html>