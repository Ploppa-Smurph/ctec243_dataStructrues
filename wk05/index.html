<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTEC243 Data Structures wk05: Queue ADT (Abstract Data Type)</title>
</head>
<body>
<h1>CTEC243 Data Structures wk05: Ch04 - Queue ADT (Abstract Data Type)</h1>
<pre>
<h2>04.01 - The Queue</h2> 
    ** Queues are FIFO structures. First-In; First-Out 

    <strong>Constructors</strong>
        - <em><strong>new</strong></em>used to create an empty queue

    <strong>Transformers</strong> -- modify the code, mutate the queue
        - <em><strong>enqueue</strong></em> - add element to rear
        - <em><strong>dequeue</strong></em> - remove and return element from front of queue

    <strong>Queue Usages</strong>
        - <em>OS often maintain process queue of events waiting to execute based on another event to occur</em>
        - <em>Computers often have a "buffer" which is a holding area for communication between processes or programs. The buffer is queued.</em>
        - <em>Real world queues include buying pizza, going to theater, waiting in line anywhere...</em>

<h2>04.02 - The Queue Interface</h2> 

Interfaces tell us what the Queue has to be able to do, but not how it does it

    Similar approach to the 'Stack Interface' ADT.
        build our own Queue interface with working enque & dequeue

        enqueue(T element) -- can throw overflow exception, adds to queue rear
        T dequeue() -- can cause underflow exception, removes from queue front
        boolean 
            - isFull() 
            - isEmpty()

        int size() -- returns number of elements in queue

<h2>04.03 - Array-Based Queue Implementations</h2>
    fixed-front design is flawed. (fixed-front after you dequeue an element you shift each additional element to the left 1 space [to refill index 0])
    moving-front design is flawed. (as you dequeue an element you shift the front of the queue to the right to and eventually have a very limited queue to work with)

    floating-front -- has a floating front and rear. as the array moves the front and consumes the array, we loop around and use the old beginning of the array as the new end
    <strong>Bounded queue</strong> 

    <strong>Unbounded queue</strong>
            allows you to 'enlarge' array as needed
            setup the default capacity
            setup an original capacity 

<h2>04.04 - An Interactive Test Driver</h2>
<h2>04.05 - Link-Based Queue Implementations</h2>
    <strong>Link-Based Queue Implementations</strong>
    <code>
    public class LinkedQueue<T> implements QueueInterface<T> {
    protected LLNode<T> front;
    protected LLNode<T> rear;
    protected int numElements = 0;
    
    public LinkedQueue() {
        front = null;
        rear = null;
      }
    }
    </code>

    you also have to reassign 'rear' as you add new elements to nodes, the rear node increments up
      as you dequeue the rear will need to decrement down 

<h2>04.06 - Application: Palindromes</h2>
<h2>04.07 - Queue Variations</h2>
    <strong>Deque = Double Queue</strong> 
        <em>Deques 'enqueue' and 'dequeue' from the front or rear, either end!!</em>

    <strong>4 Java Deque Interface Libraries:</strong>
        - <em>ArrayDeque</em>
        - <em>ConcurrentLinkedDeque</em>
        - <em>LinkedBlockingDeque</em>
        - <em>LinkedList</em>

        Java Queue -- add(E) [instead of enqueue]
                    - offer() [instead of dequeue]
                    - peek()

<h2>04.08 - Application: Average Waiting Time</h2>
<h2>04.09 - Concurrency, Interference, and Synchronization</h2>

<h2>04 - Review</h2>
<strong>01) Suppose you start with an empty queue and perform the following operations: enqueue 1, dequeue,
    enqueue 2, dequeue, enqueue 3, enqueue 4, dequeue, dequeue, enqueue 5. What are the resultant
    contents of the queue, from front to back?</strong>
    <em>None of these is correct, it is 5</em>

<strong>02) Recall that within the LinkedQueue the front and rear variables are of type LLNode<T> holding
    references to the front and rear nodes of the underlying linked list, and the numElements variable is an
    int and holds the current size of the queue. Which of the following code sequences could be used to
    correctly implement the isEmpty operation?</strong>
    <em>return (rear == null);

        return (front == null);
        
        return (numElements == 0);
        
        All of these are correct.</em>

<strong>03) Suppose you start with an empty queue and perform the following operations: enqueue 1, enqueue 2,
    dequeue, enqueue 3, enqueue 4, dequeue, enqueue 5. What are the resultant contents of the queue,
    from front to back?</strong>
    <em>3,4,5</em>

<strong>04) The following sequence of operations essentially leaves a queue unchanged.</strong>   
    <em>enqueue followed by dequeue</em>

<strong>05) How did the text decide to handle the possibility of queue underflow?</strong>
    <em>Throw a QueueUnderflowException if it occurs, and provide an isEmpty operation so a client can prevent underflow.</em>

<strong>06) True or False? We use a call to the join method to indicate that the main thread should wait until
    another thread has completed executing before continuing.</strong>
    <em>True</em>

<strong>07) True or False? The isEmpty operation as defined for the text's Queue ADT might throw the
    QueueUnderflowException.</strong>
    <em>False</em>

<strong>08) True or False? A java interface can inherit from at most one other interface.</strong>   
    <em>False</em>

<strong>09) True or False? A "dequeue" allows an application to peek at the front of rear values of a queue.</strong>
    <em>False</em>

<strong>10) True or False? A queue is a first in, first out structure.</strong>
    <em>True</em>

<strong>11) True or False? If N represents the number of elements in the queue, then the size method of the
    ArrayBoundedQueue class is O(N).</strong>
    <em>False</em>

<strong>13) True or False? If you enqueue 5 elements into an empty queue, and then perform the isEmpty operation 5
    times, the queue will be empty again.</strong>   
    <em>False</em>

<strong>14) True or False? A standard linked list provides a good implementation of a "Deque".</strong>
    <em>False</em>

<strong>15) True or False? When implementing a queue with a linked list, the front of the queue is also the front
    of the linked list.</strong>
    <em>True</em>
</pre>
</body>
</html>