<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTEC 243 Data Structures wk04: Recursion </title>
</head>
<body>
<pre>
<h1>CTEC 243 Data Structures wk04: Recursion</h1>
<h2>03.01 - Recursion</h2>
    ** can be slower and less-efficient than imperative solution
     + can be easier to read than a longer more detailed imperative solution
     - recursion can result in overflow (stack overflow) as it adds more and more items to the stack

    <strong>Recursion Depth</strong> - how many times the method calls itself
    <strong>Base Case</strong> - scenario which the problem can be solved without recursion 
    <strong>Recursive Case</strong> - a scenario you can use recursion to solve 
    <strong>Direct Recursion</strong> - recursion in which a method directly calls itself
    <strong>Indirect Recursion</strong> - recursion in which a chain of 2 or more method calls returns to the method that originated the chain. 
        <em>ex: 'method A' calls 'method B' which in turn calls 'method A'</em>

    <strong>3 Questions in Recursion</strong>
        <em>Base-Case Question</em> - is there a non-recursive way out?
        <em>Smaller-Caller Question</em> - does every recursive call move towards the Base-Case?
        <em>General-Case Question</em> - does it do what you want it to?

    <strong><em>ex: Factorials</em></strong>
        n! -- if you see a number, or 'n' with and ! next to it that is a factorial
            <em>factorials - you take the number and multiply it by every number up until and including itself</em>
            <em>ex: 6! = 1 * 2 * 3 * 4 * 5 * 6</em>

            <em>0! = 1</em> -- that is a math rule 
    
    go to /projects/java/243/recursionexamples - for the programming sample of this video

<h2>03.02 - Recursion pt 02: Dynamic Storage Allocation</h2>
     * tail recursion DOES NOT optimize memory in Java

     <strong>Accumulators</strong> - parameter you can pass into a recursive method
        The accumumlator "accumulates" information in each call

    A recursive algorithm is 'Tail-Recursive' if you can replace it with a 'while' loop

    If the recursive algorithm is NOT 'Tail-Recursive' then you may still be able to create an iterative solution

    ** in many languages Iterative solutions are more efficient than Recursive ones

<h2>03.03 - </h2>

<h2>03 - Review</h2>
<strong>01) Assuming values is a full array of int, what does the following recursive method return (assume it is
    passed a legal argument, a value between 0 and values.length)?</strong>
    <code>int mystery(int n)
        {
            if (n == values.length)
                return 0;
            else
                return (n + mystery(n + 1));
            }   </code>
    <em>none of these is correct</em>

<strong>02) Given that values is of type LLNode<Integer> and references a linked list (non-empty) of Integer
    objects, what does the following code do if invoked as mystery(values)?</strong>
    <code>
    void mystery(LLNode<Integer> list)
    {
      if (list != null)
      {
        System.out.println(list.getInfo());
        mystery(list.getLink());
      }
    }</code>
    <em>Prints the list from start to end</em>

<strong>03) Recursion is implemented by the system:</strong>
    <em>using run time storage allocation.</em>

<strong>04) The number of recursive calls that a method goes through before returning is called:</strong>
    <em>the depth of recursion</em>

<strong>05) Given that values is of type LLNode<Integer> and references a linked list (possibly empty) of
    Integer objects, what does the following code do if invoked as mystery(values)?</strong>
    <code>int mystery(LLNode<Integer> list)
        {
          if (list == null)
            return 0;
          else
            return mystery(list.getLink());
        }
        </code>
    <em>return 0</em>

<strong>06) True or False? Recursive methods often have fewer local variables than the equivalent nonrecursive
    methods.</strong>
    <em>True</em>

<strong>07) The base case does not exist or is not reached when there is infinite recursion.</strong>
    <em>True</em>

<strong>08) True or False? Recursive algorithms are usually implemented with while loops.</strong>
    <em>False</em>

<strong>09) True or False? The binary search algorithm is O(N) where N is the size of the sorted array.</strong>
    <em>False</em>

<strong>10) True or False? The static storage allocation approach creates space for a method when the method
    is invoked.</strong>
    <em>False</em>

<strong>11) The following code is supposed to return n!, for positive n. An analysis of the code using our "Three
    Question" approach reveals that:</strong>
    <code>int factorial(int n){
        if (n == 0)
          return 1;
        else
          return (n + factorial(n - 1));
      }</code>
    <em></em>

<strong>12) What does the following return, when passed the argument 1564?</strong>
    <code>int recur(int n)
        {
          if (n < 0) return -1;
          else
            if (n < 10) return n;
            else
              return ((n % 10) + recur(n / 10));
        }</code>
    <em>16</em>

<strong>13) True or False? Recursive methods must always contain a path that does not contain a recursive call.</strong>
    <em>True</em>

<strong>14) True or False? Recursive methods are always shorter and clearer than the equivalent nonrecursive
    methods.</strong>
    <em>False</em>


</pre>    
</body>
</html>