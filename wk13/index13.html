<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTEC 243 wk13 Ch11: Sorting and Searching Algorithms</title>
</head>

<body>
    <pre>
<h1></h1>
<h2>11.01 - Sorting (Selection Sort)</h2> = O(n^2)
    <a href url="https://youtu.be/cqh8nQwuKNE">Joe James' Java Selection Sort youtube video</a>
    
    <strong>Selection Sort</strong> - finds smallest item and returns to 1st node of list
        ** NOT fast -- O(n^2) -- slow
    
    <code>
        public int[] selectionSort (int[] list) {               -- create int array named selectionSort that accepts an array of ints with a variable named list
            int i, j, minValue, minIndex, temp = 0              -- declare / create int variable name i, j, minValue, minIndex, temp and set them all to 0

            for (i = 0; i < list.length; i++) {                 -- iterate through the length of the list array
                minValue = list[i];
                minIndex = i;                                   -- initialize 'minValue' and 'minIndex' to i (1st unsorted item in list each time outer loop iterates)
                for (j = i; j < list.length; j++) {             -- inner for loop begins with j set as mutable i for temp comparison purposes
                    if (list[j] < minValue) {                   -- this checks to see if the list item 'j' is less than minValue
                        minValue = list[j];                     -- minValue is set to 'j' if j is less than the initial minValue
                        minIndex = j;                           -- the index is then set to j
                    }
                }
            if (minValue < list[i]) {                           -- after each iteration of the loop we check to see if minValue is still less than the first list value, if the minValue is less there  is no need to swap  
                temp = list[i];                                 -- the beginning of the swap if minValue is greater than list[i] value.
                list[i] = list[minIndex];
                list[minIndex] = temp;
            }
        }            
            return list;                                        -- return the list
    }
    </code>

<h3>11.02b - Insertion Sorts</h3> = O(n^2)
    <a href url="https://youtu.be/lCDZ0IprFw4">Joe James' Java Insertion Sort YouTube video</a>
    
    <strong>Insertion Sort</strong> - all items to the left of the item are smaller than the item
    ** O(n^2) = NOT a fast sorting algorithm because it uses nested loops
        - useful for small datasets
    

<h3>11.02c - BubbleSort Algorithm</h3> = O(n^2)
<a href url="https://youtu.be/F13_wsHDIG4">Joe James' Java BubbleSort Algorithm</a>

    <strong>BubbleSort</strong> - given an array of items it will sort in increasing order
      - Compares 2 adjacent items and puts larger item to the right

      ++ within the 1st iteration the largest value has 'bubbled' all the way to the right (the end spot)

<h2>11.03 - O(N(log2N)) Sorts</h2>
<h3>11.03a - Merge Sort</h3> = O(n log n)
    <a href url="https://youtu.be/iMT7gTPpaqw">Joe James' Java Merge Sort YouTube video</a>

    <strong>Merge Sort</strong> - sorts in ascending order 
    ** splits the element total in half, then splits that in half again until there are lists of only single items to compare
    once the lists are sorted then the they are compared and added back to the larger total, until the process is completed.

    ** Recursive algorithm; 
    ++ faster -- each step doubles the size of the pool, so it is completed quickly

<h3>11.03b - Quick Sort</h3> = O(n log n)
    <a href url="https://youtu.be/Fiot5yuwPAg">Joe James' Java Quick Sort YouTube video</a>

    <strong>Quick Sort</strong> - uses the 'pivot' (a value in the array) and then moves values that are smaller to the left and values that are larger to the right.
     -- the left partition is < the pivot
     -- the right partition is > the pivot 

     ** Recursive algorithm; a 'divide-and-conquor' algorithm since it breaks the items down into simpler smaller pieces
     + efficient for large data sets

     -- Worst case = O(n^2)
     == Average case = O(n log n) == use a randomly chosen pivot for best outcomes

<h2>11.04 - More Sorting Considerations</h2>

<h2>11.05 - Searching</h2>

<h2>11.06 - Heaps and Heap Sort</h2>
<h3>11.04a Heaps and Heap Sorts</h3> -- slower than 'merge sort'
<a href url="https://youtu.be/H5kAcmGOn4Q">Heaps and Heap Sort YouTube video</a>
    <strong>Heap</strong> - heap is a tree; sift down when an item is replaced to return to heap criteria

    <strong>Siftdown</strong> - process of returning incorrect item at top to it's proper spot

    <strong>Heapify</strong> - process of making data into a heap; the the siftdown happens to organize the heap properly

    <strong>Siftup</strong> - when item is added it is added to the end (bottom) of the tree and is then sifted up into it's correct position in the tree

    <strong>Heap Sort</strong> - slowly adds each item from the data set to correctly build the heap as it goes; slower than heapify method

<h2>11.05 - Searching</h2>    

This section reviews material scattered throughout the text related to searching.
• Here we bring these topics together to be considered in relationship to each other to gain
an overall perspective.
• Searching is a crucially important information processing activity. Options are closely related to
the way data is structured and organized. 

<strong>Sequential Searching</strong>
• If we want to add elements as quickly as possible to a collection, and we are not as concerned about how long
it takes to find them we would put the element 
    – into the last slot in an array-based collection
    – into the first slot in a linked collection
• To search this collection for the element with a given key, we must use a simple linear (or sequential) search
    – Beginning with the first element in the collection, we search for the desired element by examining each subsequent element’s
key until either the search is successful or the collection is exhausted.
– Based on the number of comparisons this search is O(N)
– In the worst case we have to make N key comparisons.
– On the average, assuming that there is an equal probability of searching for any element in the collection, we make N/2
comparisons for a successful search High-Probability Ordering 
• Sometimes certain collection elements are in much greater demand than others. We can then improve the
search:
– Put the most-often-desired elements at the beginning of the
collection
– Using this scheme, we are more likely to make a hit in the first
few tries, and rarely do we have to search the whole collection.
• If the elements in the collection are not static or if we
cannot predict their relative demand, we can
– move each element accessed to the front of the collection
– as an element is found, it is swapped with the element that
precedes it
• collections in which the relative positions of the elements
are changed in an attempt to improve search efficiency
are called self-organizing or self-adjusting collections.
Sorted collections
• If the collection is sorted, a sequential search no longer needs to
search the whole collection to discover that an element does not
exist. It only needs to search until it has passed the element’s logical
place in the collection—that is, until an element with a larger key
value is encountered.
• Another advantage of linear searching is its simplicity.
• The binary search is usually faster, however, it is not guaranteed to
be faster for searching very small collections.
• As the number of elements increases, however, the disparity
between the linear search and the binary search grows very quickly.
• The binary search is appropriate only for collection elements stored
in a sequential array-based representation.
• However, the binary search tree allows us to perform a binary
search on a linked data representation
Hashing
• We end our discussion of search
algorithms by pointing out that the hash
table approach to storage presented in
Sections 4 through 6 of Chapter 8 allows
constant search time in many situations.
<h2>11 - Review</h2>
<strong>01) True or False? The efficiency of the Insertion Sort is O(N2) where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>02) True or False? The efficiency of the Merge Sort is O(N2), where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>03) True or False? After one pass of the Bubble Sort, the smallest element is in its correct place in the array.</strong>
    <em>True</em>

<strong>04) True or False?  For a "randomly arranged" array, the efficiency of the Quick Sort is O(Nlog2N) where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>05) True or False?  The efficiency of the Heap Sort is O(N2), where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>06) True or False?  The efficiency of the Quick Sort is always O(Nlog2N), where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>07) True or False?  The efficiency of the Heap Sort is O(Nlog2N), where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>08) True or False?  The efficiency of the Selection Sort is O(N2), where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>09) True or False?  In the worst case, Quick Sort uses O(log2N) extra space, where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>10) True or False? After one pass of the Selection Sort the largest element is in its correct place in the array.</strong>
    <em>False</em>

<strong>11) True or False?  The efficiency of the Quick Sort is O(N2) in the worst case, where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>12) rue or False? After one pass of the Selection Sort, the smallest element is in its correct place in the array.</strong>
    <em>True</em>

<strong>13) True or False?  In the best case, Quick Sort uses O(log2N) extra space, where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>14) True or False?  In the worst case, Quick Sort uses O(N) extra space, where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>15) True or False? You can perform a binary search on an unsorted array.</strong>
    <em>False</em>

</pre>
</body>

</html>