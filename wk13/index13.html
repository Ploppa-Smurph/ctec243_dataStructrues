<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTEC 243 wk13 Ch11: Sorting and Searching Algorithms</title>
</head>

<body>
    <pre>
<h1></h1>
<h2>11.01 - Sorting (Selection Sort)</h2> = O(n^2)
    <a href url="https://youtu.be/cqh8nQwuKNE">Joe James' Java Selection Sort youtube video</a>
    
    <strong>Selection Sort</strong> - finds smallest item and returns to 1st node of list
        ** NOT fast -- O(n^2) -- slow
    
    <code>
        public int[] selectionSort (int[] list) {               -- create int array named selectionSort that accepts an array of ints with a variable named list
            int i, j, minValue, minIndex, temp = 0              -- declare / create int variable name i, j, minValue, minIndex, temp and set them all to 0

            for (i = 0; i < list.length; i++) {                 -- iterate through the length of the list array
                minValue = list[i];
                minIndex = i;                                   -- initialize 'minValue' and 'minIndex' to i (1st unsorted item in list each time outer loop iterates)
                for (j = i; j < list.length; j++) {             -- inner for loop begins with j set as mutable i for temp comparison purposes
                    if (list[j] < minValue) {                   -- this checks to see if the list item 'j' is less than minValue
                        minValue = list[j];                     -- minValue is set to 'j' if j is less than the initial minValue
                        minIndex = j;                           -- the index is then set to j
                    }
                }
            if (minValue < list[i]) {                           -- after each iteration of the loop we check to see if minValue is still less than the first list value, if the minValue is less there  is no need to swap  
                temp = list[i];                                 -- the beginning of the swap if minValue is greater than list[i] value.
                list[i] = list[minIndex];
                list[minIndex] = temp;
            }
        }            
            return list;                                        -- return the list
    }
    </code>

<h3>11.02b - Insertion Sorts</h3> = O(n^2)
    <a href url="https://youtu.be/lCDZ0IprFw4">Joe James' Java Insertion Sort YouTube video</a>
    
    <strong>Insertion Sort</strong> - all items to the left of the item are smaller than the item
    ** O(n^2) = NOT a fast sorting algorithm because it uses nested loops
        - useful for small datasets
    

<h3>11.02c - BubbleSort Algorithm</h3> = O(n^2)
<a href url="https://youtu.be/F13_wsHDIG4">Joe James' Java BubbleSort Algorithm</a>

    <strong>BubbleSort</strong> - given an array of items it will sort in increasing order
      - Compares 2 adjacent items and puts larger item to the right

      ++ within the 1st iteration the largest value has 'bubbled' all the way to the right (the end spot)

<h2>11.03 - O(N(log2N)) Sorts</h2>
<h3>11.03a - Merge Sort</h3> = aka "Divide-and-Conquer" algorithm; O(n log n)
    <a href url="https://youtu.be/iMT7gTPpaqw">Joe James' Java Merge Sort YouTube video</a>

    <strong>Merge Sort</strong> - sorts in ascending order 
    ** splits the element total in half, then splits that in half again until there are lists of only single items to compare
    once the lists are sorted then the they are compared and added back to the larger total, until the process is completed.

    ** Recursive algorithm; 
    ++ faster -- each step doubles the size of the pool, so it is completed quickly

<h3>11.03b - Quick Sort</h3> = O
    <a href url="https://youtu.be/Fiot5yuwPAg">Joe James' Java Quick Sort YouTube video</a>
    

<h2>11.04 - More Sorting Considerations</h2>

<h2>11.05 - Searching</h2>

<h2>11.06 - Heaps and Heap Sort</h2>

<h2>11 - Review</h2>
<strong>01) True or False? The efficiency of the Insertion Sort is O(N2) where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>02) True or False? The efficiency of the Merge Sort is O(N2), where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>03) True or False? After one pass of the Bubble Sort, the smallest element is in its correct place in the array.</strong>
    <em>True</em>

<strong>04) True or False?  For a "randomly arranged" array, the efficiency of the Quick Sort is O(Nlog2N) where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>05) True or False?  The efficiency of the Heap Sort is O(N2), where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>06) True or False?  The efficiency of the Quick Sort is always O(Nlog2N), where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>07) True or False?  The efficiency of the Heap Sort is O(Nlog2N), where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>08) True or False?  The efficiency of the Selection Sort is O(N2), where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>09) True or False?  In the worst case, Quick Sort uses O(log2N) extra space, where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>10) True or False? After one pass of the Selection Sort the largest element is in its correct place in the array.</strong>
    <em>False</em>

<strong>11) True or False?  The efficiency of the Quick Sort is O(N2) in the worst case, where N is the size of the list being sorted.</strong>
    <em>False</em>

<strong>12) rue or False? After one pass of the Selection Sort, the smallest element is in its correct place in the array.</strong>
    <em>True</em>

<strong>13) True or False?  In the best case, Quick Sort uses O(log2N) extra space, where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>14) True or False?  In the worst case, Quick Sort uses O(N) extra space, where N is the size of the list being sorted.</strong>
    <em>True</em>

<strong>15) True or False? You can perform a binary search on an unsorted array.</strong>
    <em>False</em>

</pre>
</body>

</html>